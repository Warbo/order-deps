From 0f266ecaca6c8c81a495d0c59151810c3b37affe Mon Sep 17 00:00:00 2001
From: Ouanis Seddaoui <ouanixi@gmail.com>
Date: Fri, 21 Aug 2015 20:38:40 +0100
Subject: [PATCH] initial commit

---
 src/Grapher.hs | 27 +++++++++++++++++++++++++++
 src/Jparse.hs  | 24 ++++++++++++++++++++++++
 src/Main.hs    | 14 ++++++++++++++
 3 files changed, 65 insertions(+)

diff --git a/src/Grapher.hs b/src/Grapher.hs
new file mode 100644
index 0000000000000000000000000000000000000000..5347424a6933e4b9217c41de021aafed7f9c36ab
--- /dev/null
+++ b/src/Grapher.hs
@@ -0,0 +1,27 @@
+{-# LANGUAGE OverloadedStrings #-}
+module Grapher where
+
+import           Data.Graph
+import           Data.Text
+import           Jparse
+
+
+type Atom = (Text, Text, Text)
+type Graphable = [(Atom, Atom,[Atom])]
+
+extractAtoms :: Maybe [ASTId] -> [Atom]
+extractAtoms (Just (x:xs)) = (name x, modu x, package x) : extractAtoms (pure xs)
+extractAtoms _             = []
+
+extractGraphable :: ASTId -> (Atom , Atom, [Atom])
+extractGraphable ASTId {
+                        name = name,
+                        modu = modu,
+                        package = package,
+                        dependencies = dependencies
+                        } = ((name,modu,package), (name,modu,package), extractAtoms dependencies)
+
+
+dependencySort :: Graphable -> [Atom]
+dependencySort x = let (g,v,_) = graphFromEdges x
+            in Prelude.map (\x -> let (k,_,_) = v x in k) $ topSort g
diff --git a/src/Jparse.hs b/src/Jparse.hs
new file mode 100644
index 0000000000000000000000000000000000000000..dc12466d64819f19c2b65fb855b2aecf265a136b
--- /dev/null
+++ b/src/Jparse.hs
@@ -0,0 +1,24 @@
+{-# LANGUAGE DeriveGeneric     #-}
+{-# LANGUAGE OverloadedStrings #-}
+module Jparse where
+
+import           Control.Applicative
+import           Control.Monad
+import           Data.Aeson
+import qualified Data.ByteString.Lazy as B
+import qualified Data.Graph           as G
+import qualified Data.Map             as Map
+import           Data.Text
+import           GHC.Generics
+
+
+
+data ASTId =
+  ASTId {  name         :: Text
+         , modu         :: Text
+         , package      :: Text
+         , dependencies :: Maybe [ASTId]
+        } deriving (Show, Generic)
+
+instance FromJSON ASTId
+instance ToJSON ASTId
diff --git a/src/Main.hs b/src/Main.hs
new file mode 100644
index 0000000000000000000000000000000000000000..c86a4b762658d48e38702634a2de2e209beca29d
--- /dev/null
+++ b/src/Main.hs
@@ -0,0 +1,14 @@
+{-# LANGUAGE OverloadedStrings #-}
+import           Data.Aeson
+
+import qualified Data.ByteString.Lazy as B
+import           Grapher
+import           Jparse
+
+main :: IO ()
+main = do
+ -- Get JSON data and decode it
+ d <- (eitherDecode <$> B.getContents) :: IO (Either String [ASTId])
+ case d of
+  Left err -> putStrLn err
+  Right ps -> putStrLn . show $ map extractGraphable ps

From e37623587e6c75aa4d7812b9f7d93ae414697ccb Mon Sep 17 00:00:00 2001
From: Ouanis Seddaoui <ouanixi@gmail.com>
Date: Fri, 21 Aug 2015 20:53:25 +0100
Subject: [PATCH] added comments

---
 src/Grapher.hs | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 5347424a6933e4b9217c41de021aafed7f9c36ab..3596beb2ef703cfcdc5a89c70cbf5f3a202833ca 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -9,10 +9,14 @@ import           Jparse
 type Atom = (Text, Text, Text)
 type Graphable = [(Atom, Atom,[Atom])]
 
+
+-- Handles the case of the Json Key being a Maybe [ASTId]
 extractAtoms :: Maybe [ASTId] -> [Atom]
 extractAtoms (Just (x:xs)) = (name x, modu x, package x) : extractAtoms (pure xs)
 extractAtoms _             = []
 
+
+-- Turns a Json object into a tuple that's acceptable by graphFromEdges
 extractGraphable :: ASTId -> (Atom , Atom, [Atom])
 extractGraphable ASTId {
                         name = name,
@@ -22,6 +26,9 @@ extractGraphable ASTId {
                         } = ((name,modu,package), (name,modu,package), extractAtoms dependencies)
 
 
+-- graphFromEdges :: Ord key => [(Atom, Atom, [Atom])]
+--                              -> (Graph, Vertex -> (Atom, Atom, [Atom]), Atom -> Maybe Vertex)
 dependencySort :: Graphable -> [Atom]
+dependencySort [] = []
 dependencySort x = let (g,v,_) = graphFromEdges x
             in Prelude.map (\x -> let (k,_,_) = v x in k) $ topSort g

From b4ee7e6808d54b4efe42abe2c9d1b237e9f74f7d Mon Sep 17 00:00:00 2001
From: Ouanis Seddaoui <ouanixi@gmail.com>
Date: Mon, 24 Aug 2015 12:34:30 +0100
Subject: [PATCH] rearannged output to group cyclic nodes together

---
 src/Grapher.hs | 12 ++++++++----
 src/Main.hs    |  7 ++++++-
 2 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 3596beb2ef703cfcdc5a89c70cbf5f3a202833ca..5fd1d87b2bad2148bebb3a648f79d0d50b177433 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -10,6 +10,10 @@ type Atom = (Text, Text, Text)
 type Graphable = [(Atom, Atom,[Atom])]
 
 
+instance Show v => Show (SCC v) where
+  show (AcyclicSCC v) = show [v]
+  show (CyclicSCC lv) = show lv
+
 -- Handles the case of the Json Key being a Maybe [ASTId]
 extractAtoms :: Maybe [ASTId] -> [Atom]
 extractAtoms (Just (x:xs)) = (name x, modu x, package x) : extractAtoms (pure xs)
@@ -28,7 +32,7 @@ extractGraphable ASTId {
 
 -- graphFromEdges :: Ord key => [(Atom, Atom, [Atom])]
 --                              -> (Graph, Vertex -> (Atom, Atom, [Atom]), Atom -> Maybe Vertex)
-dependencySort :: Graphable -> [Atom]
-dependencySort [] = []
-dependencySort x = let (g,v,_) = graphFromEdges x
-            in Prelude.map (\x -> let (k,_,_) = v x in k) $ topSort g
+-- dependencySort :: Graphable -> [Atom]
+-- dependencySort [] = []
+-- dependencySort x = let (g,v,_) = graphFromEdges x
+--             in Prelude.map (\x -> let (k,_,_) = v x in k) $ topSort g
diff --git a/src/Main.hs b/src/Main.hs
index c86a4b762658d48e38702634a2de2e209beca29d..558d24597c34665bc11ef1ac89b238f2f22b1b30 100644
--- a/src/Main.hs
+++ b/src/Main.hs
@@ -2,6 +2,7 @@
 import           Data.Aeson
 
 import qualified Data.ByteString.Lazy as B
+import           Data.Graph
 import           Grapher
 import           Jparse
 
@@ -11,4 +12,8 @@ main = do
  d <- (eitherDecode <$> B.getContents) :: IO (Either String [ASTId])
  case d of
   Left err -> putStrLn err
-  Right ps -> putStrLn . show $ map extractGraphable ps
+  Right ps -> print $ stronglyConnComp $ map extractGraphable ps
+
+
+
+-- $ stronglyConnComp

From dffba7463ba299f0a33ea19c4f13b0f8cdd90fbf Mon Sep 17 00:00:00 2001
From: Ouanis Seddaoui <ouanixi@gmail.com>
Date: Tue, 25 Aug 2015 15:02:50 +0100
Subject: [PATCH] reconfigured for cabal 1.22.4

---
 src/Grapher.hs | 8 --------
 1 file changed, 8 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 5fd1d87b2bad2148bebb3a648f79d0d50b177433..6187f97ccf94a47a8ee29f02aab15a896479e5e4 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -28,11 +28,3 @@ extractGraphable ASTId {
                         package = package,
                         dependencies = dependencies
                         } = ((name,modu,package), (name,modu,package), extractAtoms dependencies)
-
-
--- graphFromEdges :: Ord key => [(Atom, Atom, [Atom])]
---                              -> (Graph, Vertex -> (Atom, Atom, [Atom]), Atom -> Maybe Vertex)
--- dependencySort :: Graphable -> [Atom]
--- dependencySort [] = []
--- dependencySort x = let (g,v,_) = graphFromEdges x
---             in Prelude.map (\x -> let (k,_,_) = v x in k) $ topSort g

From 4bf709a3476f20bfcae11234dcdddbca1883bfd2 Mon Sep 17 00:00:00 2001
From: Ouanis Seddaoui <ouanixi@gmail.com>
Date: Thu, 27 Aug 2015 20:35:27 +0100
Subject: [PATCH] random value generation sorted (a bit of a hack)

---
 src/Grapher.hs | 14 +++++++-------
 src/Jparse.hs  |  7 +------
 src/Main.hs    |  2 --
 3 files changed, 8 insertions(+), 15 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 6187f97ccf94a47a8ee29f02aab15a896479e5e4..a9b1b8b58292e1f06dba641198ee02535a2bc47d 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -2,7 +2,7 @@
 module Grapher where
 
 import           Data.Graph
-import           Data.Text
+import           Data.Text  (Text)
 import           Jparse
 
 
@@ -16,15 +16,15 @@ instance Show v => Show (SCC v) where
 
 -- Handles the case of the Json Key being a Maybe [ASTId]
 extractAtoms :: Maybe [ASTId] -> [Atom]
-extractAtoms (Just (x:xs)) = (name x, modu x, package x) : extractAtoms (pure xs)
+extractAtoms (Just a)      = map (\ x -> (name x, modu x, package x)) a
 extractAtoms _             = []
 
 
 -- Turns a Json object into a tuple that's acceptable by graphFromEdges
 extractGraphable :: ASTId -> (Atom , Atom, [Atom])
 extractGraphable ASTId {
-                        name = name,
-                        modu = modu,
-                        package = package,
-                        dependencies = dependencies
-                        } = ((name,modu,package), (name,modu,package), extractAtoms dependencies)
+                        name = n,
+                        modu = m,
+                        package = p,
+                        dependencies = d
+                        } = ((n,m,p), (n,m,p), extractAtoms d)
diff --git a/src/Jparse.hs b/src/Jparse.hs
index dc12466d64819f19c2b65fb855b2aecf265a136b..1ddb8dbcc6b23585a03b3c852b5eb65bdbe34d87 100644
--- a/src/Jparse.hs
+++ b/src/Jparse.hs
@@ -2,12 +2,7 @@
 {-# LANGUAGE OverloadedStrings #-}
 module Jparse where
 
-import           Control.Applicative
-import           Control.Monad
 import           Data.Aeson
-import qualified Data.ByteString.Lazy as B
-import qualified Data.Graph           as G
-import qualified Data.Map             as Map
 import           Data.Text
 import           GHC.Generics
 
@@ -18,7 +13,7 @@ data ASTId =
          , modu         :: Text
          , package      :: Text
          , dependencies :: Maybe [ASTId]
-        } deriving (Show, Generic)
+        } deriving (Show, Generic, Eq)
 
 instance FromJSON ASTId
 instance ToJSON ASTId
diff --git a/src/Main.hs b/src/Main.hs
index 558d24597c34665bc11ef1ac89b238f2f22b1b30..d4fb7a98190b5bb027681745e49b8c9c32e7f52b 100644
--- a/src/Main.hs
+++ b/src/Main.hs
@@ -15,5 +15,3 @@ main = do
   Right ps -> print $ stronglyConnComp $ map extractGraphable ps
 
 
-
--- $ stronglyConnComp

From 6586da19259afc208dca8d3692c5efe1fe797814 Mon Sep 17 00:00:00 2001
From: Chris Warburton <chriswarbo@gmail.com>
Date: Wed, 4 Nov 2015 00:01:49 +0000
Subject: [PATCH] Move stuff around

---
 src/Grapher.hs | 14 +++++++++++---
 src/Jparse.hs  | 20 +++++---------------
 src/Main.hs    | 13 +++----------
 src/Types.hs   | 36 ++++++++++++++++++++++++++++++++++++
 4 files changed, 55 insertions(+), 28 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index a9b1b8b58292e1f06dba641198ee02535a2bc47d..375cfa14beba9abd1208d2dce02871ff176dcb3c 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -1,15 +1,15 @@
 {-# LANGUAGE OverloadedStrings #-}
 module Grapher where
 
+import           Data.Aeson
+import qualified Data.ByteString.Lazy as B
 import           Data.Graph
 import           Data.Text  (Text)
-import           Jparse
-
+import           Types
 
 type Atom = (Text, Text, Text)
 type Graphable = [(Atom, Atom,[Atom])]
 
-
 instance Show v => Show (SCC v) where
   show (AcyclicSCC v) = show [v]
   show (CyclicSCC lv) = show lv
@@ -28,3 +28,11 @@ extractGraphable ASTId {
                         package = p,
                         dependencies = d
                         } = ((n,m,p), (n,m,p), extractAtoms d)
+
+parse :: B.ByteString -> [ASTId]
+parse s = case eitherDecode s of
+               Left err -> error err
+               Right ps -> ps
+
+process :: [ASTId] -> [[ASTId]]
+process = stronglyConnComp . map extractGraphable
diff --git a/src/Jparse.hs b/src/Jparse.hs
index 1ddb8dbcc6b23585a03b3c852b5eb65bdbe34d87..8c78ff1406b1439d9dc2e617e14a8a5a5f630390 100644
--- a/src/Jparse.hs
+++ b/src/Jparse.hs
@@ -1,19 +1,9 @@
-{-# LANGUAGE DeriveGeneric     #-}
 {-# LANGUAGE OverloadedStrings #-}
+
 module Jparse where
 
 import           Data.Aeson
-import           Data.Text
-import           GHC.Generics
-
-
-
-data ASTId =
-  ASTId {  name         :: Text
-         , modu         :: Text
-         , package      :: Text
-         , dependencies :: Maybe [ASTId]
-        } deriving (Show, Generic, Eq)
-
-instance FromJSON ASTId
-instance ToJSON ASTId
+import qualified Data.ByteString.Lazy as B
+import           Data.Graph
+import qualified Data.Text            as T
+import           Types
diff --git a/src/Main.hs b/src/Main.hs
index d4fb7a98190b5bb027681745e49b8c9c32e7f52b..1a22233c9ed986a43c33b77ff36aaf743baace03 100644
--- a/src/Main.hs
+++ b/src/Main.hs
@@ -2,16 +2,9 @@
 import           Data.Aeson
 
 import qualified Data.ByteString.Lazy as B
-import           Data.Graph
-import           Grapher
 import           Jparse
 
 main :: IO ()
-main = do
- -- Get JSON data and decode it
- d <- (eitherDecode <$> B.getContents) :: IO (Either String [ASTId])
- case d of
-  Left err -> putStrLn err
-  Right ps -> print $ stronglyConnComp $ map extractGraphable ps
-
-
+main = do c <- B.getContents
+          let ps = parse c
+          print (process ps)
diff --git a/src/Types.hs b/src/Types.hs
new file mode 100644
index 0000000000000000000000000000000000000000..a197a7fb637a78a062ce3acdcdb0ee44e2c6c71d
--- /dev/null
+++ b/src/Types.hs
@@ -0,0 +1,36 @@
+{-# LANGUAGE OverloadedStrings #-}
+
+module Types where
+
+import           Control.Monad
+import           Data.Aeson
+import           HS2AST.Types
+
+data ASTId = ASTId { aId :: Identifier
+                   , aDeps :: [Identifier]
+                   } deriving (Show, Eq)
+
+instance ToJSON ASTId where
+  toJSON x = let i = aId x
+              in object [
+                     "name"         .= idName    i
+                   , "package"      .= idPackage i
+                   , "module"       .= idModule  i
+                   , "dependencies" .= aDeps     x
+                   ]
+
+instance FromJSON ASTId where
+  parseJSON (Object x) = do
+    n <- x .: "name"
+    p <- x .: "package"
+    m <- x .: "module"
+    d <- x .: "dependencies"
+    return ASTId {
+        aId = ID {
+            idName    = n
+          , idPackage = p
+          , idModule  = m
+          }
+      , aDeps = d
+      }
+  parseJSON _ = mzero

From 15534b60d31d6a90244a2fd2def424a9c5cc0c88 Mon Sep 17 00:00:00 2001
From: Chris Warburton <chriswarbo@gmail.com>
Date: Wed, 4 Nov 2015 00:02:01 +0000
Subject: [PATCH] Move stuff around

---
 src/Jparse.hs | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/Jparse.hs b/src/Jparse.hs
index 8c78ff1406b1439d9dc2e617e14a8a5a5f630390..f5513af95ea04eaf87d5359d2889270585d691b8 100644
--- a/src/Jparse.hs
+++ b/src/Jparse.hs
@@ -2,8 +2,8 @@
 
 module Jparse where
 
-import           Data.Aeson
-import qualified Data.ByteString.Lazy as B
+
+
 import           Data.Graph
 import qualified Data.Text            as T
 import           Types

From e6211a849075887afb265bff82805cac6cb89824 Mon Sep 17 00:00:00 2001
From: Chris Warburton <chriswarbo@gmail.com>
Date: Wed, 4 Nov 2015 00:15:06 +0000
Subject: [PATCH] Switch to HS2AST IDs (partially)

---
 src/Grapher.hs | 21 ++++++++++-----------
 src/Jparse.hs  |  9 ---------
 src/Main.hs    |  5 ++---
 src/Types.hs   |  4 ++++
 4 files changed, 16 insertions(+), 23 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 375cfa14beba9abd1208d2dce02871ff176dcb3c..72f6982648015ca6d097ef3d416d1231a2505290 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -5,9 +5,10 @@ import           Data.Aeson
 import qualified Data.ByteString.Lazy as B
 import           Data.Graph
 import           Data.Text  (Text)
+import           HS2AST.Types
 import           Types
 
-type Atom = (Text, Text, Text)
+type Atom      = (String, String, String)
 type Graphable = [(Atom, Atom,[Atom])]
 
 instance Show v => Show (SCC v) where
@@ -15,24 +16,22 @@ instance Show v => Show (SCC v) where
   show (CyclicSCC lv) = show lv
 
 -- Handles the case of the Json Key being a Maybe [ASTId]
-extractAtoms :: Maybe [ASTId] -> [Atom]
-extractAtoms (Just a)      = map (\ x -> (name x, modu x, package x)) a
-extractAtoms _             = []
+extractAtoms :: [Identifier] -> [Atom]
+extractAtoms a = map (\x -> (idName x, idModule x, idPackage x)) a
 
 
 -- Turns a Json object into a tuple that's acceptable by graphFromEdges
 extractGraphable :: ASTId -> (Atom , Atom, [Atom])
-extractGraphable ASTId {
-                        name = n,
-                        modu = m,
-                        package = p,
-                        dependencies = d
-                        } = ((n,m,p), (n,m,p), extractAtoms d)
+extractGraphable x = let n = aName    x
+                         m = aModule  x
+                         p = aPackage x
+                         d = aDeps    x
+                      in ((n,m,p), (n,m,p), extractAtoms d)
 
 parse :: B.ByteString -> [ASTId]
 parse s = case eitherDecode s of
                Left err -> error err
                Right ps -> ps
 
-process :: [ASTId] -> [[ASTId]]
+process :: [ASTId] -> [SCC Atom]
 process = stronglyConnComp . map extractGraphable
diff --git a/src/Jparse.hs b/src/Jparse.hs
deleted file mode 100644
index f5513af95ea04eaf87d5359d2889270585d691b8..0000000000000000000000000000000000000000
--- a/src/Jparse.hs
+++ /dev/null
@@ -1,9 +0,0 @@
-{-# LANGUAGE OverloadedStrings #-}
-
-module Jparse where
-
-
-
-import           Data.Graph
-import qualified Data.Text            as T
-import           Types
diff --git a/src/Main.hs b/src/Main.hs
index 1a22233c9ed986a43c33b77ff36aaf743baace03..8c41c7a68f4069cd0cbfdb9ed3b9eab43593e865 100644
--- a/src/Main.hs
+++ b/src/Main.hs
@@ -1,8 +1,7 @@
-{-# LANGUAGE OverloadedStrings #-}
-import           Data.Aeson
+module Main where
 
 import qualified Data.ByteString.Lazy as B
-import           Jparse
+import           Grapher
 
 main :: IO ()
 main = do c <- B.getContents
diff --git a/src/Types.hs b/src/Types.hs
index a197a7fb637a78a062ce3acdcdb0ee44e2c6c71d..35e362eb05f4f673f1355eea00d1de4abb2adda2 100644
--- a/src/Types.hs
+++ b/src/Types.hs
@@ -10,6 +10,10 @@ data ASTId = ASTId { aId :: Identifier
                    , aDeps :: [Identifier]
                    } deriving (Show, Eq)
 
+aName    = idName    . aId
+aPackage = idPackage . aId
+aModule  = idModule  . aId
+
 instance ToJSON ASTId where
   toJSON x = let i = aId x
               in object [

From 0d3f25c1e15802ae18b1022522e96d1d63c75e2b Mon Sep 17 00:00:00 2001
From: Chris Warburton <chriswarbo@gmail.com>
Date: Sun, 8 Nov 2015 12:40:54 +0000
Subject: [PATCH] HLint

---
 src/Grapher.hs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 72f6982648015ca6d097ef3d416d1231a2505290..481c4dbd38ff5d1ec2e469f8321623eec31bd51e 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -17,7 +17,7 @@ instance Show v => Show (SCC v) where
 
 -- Handles the case of the Json Key being a Maybe [ASTId]
 extractAtoms :: [Identifier] -> [Atom]
-extractAtoms a = map (\x -> (idName x, idModule x, idPackage x)) a
+extractAtoms = map (\x -> (idName x, idModule x, idPackage x))
 
 
 -- Turns a Json object into a tuple that's acceptable by graphFromEdges

From b77e8ed187048f01119796db56006fab2ee62ca1 Mon Sep 17 00:00:00 2001
From: Chris Warburton <chriswarbo@gmail.com>
Date: Fri, 20 Nov 2015 15:09:42 +0000
Subject: [PATCH] Cleaning up

---
 src/Grapher.hs | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 481c4dbd38ff5d1ec2e469f8321623eec31bd51e..96d0e707662a184c4b53f27aa49bef9187a28e41 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -8,8 +8,8 @@ import           Data.Text  (Text)
 import           HS2AST.Types
 import           Types
 
-type Atom      = (String, String, String)
-type Graphable = [(Atom, Atom,[Atom])]
+type Atom      =  (String, String, String)
+type Graphable = [(Atom,   Atom,   [Atom])]
 
 instance Show v => Show (SCC v) where
   show (AcyclicSCC v) = show [v]
@@ -19,7 +19,6 @@ instance Show v => Show (SCC v) where
 extractAtoms :: [Identifier] -> [Atom]
 extractAtoms = map (\x -> (idName x, idModule x, idPackage x))
 
-
 -- Turns a Json object into a tuple that's acceptable by graphFromEdges
 extractGraphable :: ASTId -> (Atom , Atom, [Atom])
 extractGraphable x = let n = aName    x

From fafb943bc74121394ce6c79d0ea6b5212f78e0d7 Mon Sep 17 00:00:00 2001
From: Chris Warburton <chriswarbo@gmail.com>
Date: Tue, 1 Dec 2015 05:09:56 +0000
Subject: [PATCH] Render output as JSON

---
 src/Grapher.hs | 16 ++++++++++++++--
 src/Main.hs    |  5 +++--
 2 files changed, 17 insertions(+), 4 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 96d0e707662a184c4b53f27aa49bef9187a28e41..2503b66241e92346cc1d853b61a3218c9481e6d4 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -15,6 +15,13 @@ instance Show v => Show (SCC v) where
   show (AcyclicSCC v) = show [v]
   show (CyclicSCC lv) = show lv
 
+toIds :: SCC Atom -> [Identifier]
+toIds (AcyclicSCC a)  = [atomToId a]
+toIds (CyclicSCC  as) = map atomToId as
+
+renderAll :: [SCC Atom] -> B.ByteString
+renderAll = encode . map toIds
+
 -- Handles the case of the Json Key being a Maybe [ASTId]
 extractAtoms :: [Identifier] -> [Atom]
 extractAtoms = map (\x -> (idName x, idModule x, idPackage x))
@@ -32,5 +39,10 @@ parse s = case eitherDecode s of
                Left err -> error err
                Right ps -> ps
 
-process :: [ASTId] -> [SCC Atom]
-process = stronglyConnComp . map extractGraphable
+group :: [ASTId] -> [SCC Atom]
+group = stronglyConnComp . map extractGraphable
+
+process :: [ASTId] -> B.ByteString
+process = renderAll . group
+
+atomToId (n, m, p) = ID { idPackage = p, idModule = m, idName = n }
diff --git a/src/Main.hs b/src/Main.hs
index 8c41c7a68f4069cd0cbfdb9ed3b9eab43593e865..039f35a06529959616d9742c75c71915a5c5e456 100644
--- a/src/Main.hs
+++ b/src/Main.hs
@@ -1,9 +1,10 @@
 module Main where
 
-import qualified Data.ByteString.Lazy as B
+import qualified Data.ByteString.Lazy       as B
+import qualified Data.ByteString.Lazy.Char8 as BC
 import           Grapher
 
 main :: IO ()
 main = do c <- B.getContents
           let ps = parse c
-          print (process ps)
+          BC.putStrLn (process ps)

From 4bb2fe6109036a6ab1a1da0a502e49797d751092 Mon Sep 17 00:00:00 2001
From: Chris Warburton <chriswarbo@gmail.com>
Date: Mon, 7 Mar 2016 22:17:40 +0000
Subject: [PATCH] Split off executable

---
 src/Grapher.hs | 24 +++++++++++++++++++++++-
 src/Main.hs    | 10 ----------
 2 files changed, 23 insertions(+), 11 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 2503b66241e92346cc1d853b61a3218c9481e6d4..2d2cb191d7ba546a467028d07d0fbafc4227e4dd 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -2,6 +2,7 @@
 module Grapher where
 
 import           Data.Aeson
+import qualified Data.Array as A
 import qualified Data.ByteString.Lazy as B
 import           Data.Graph
 import           Data.Text  (Text)
@@ -40,9 +41,30 @@ parse s = case eitherDecode s of
                Right ps -> ps
 
 group :: [ASTId] -> [SCC Atom]
-group = stronglyConnComp . map extractGraphable
+group ids = stronglyConnComp atoms
+  where atoms = map extractGraphable ids
+
+group' :: [ASTId] -> [SCC (Atom, Atom, [Atom])]
+group' = stronglyConnCompR . map extractGraphable
+
+leaves :: [ASTId] -> [ASTId]
+leaves = filter (null . aDeps)
+
+-- Dependencies an SCC has on Atoms outside itself
+sccDeps :: SCC (Atom, Atom, [Atom]) -> [Atom]
+sccDeps s = case s of
+    AcyclicSCC a  -> atomDeps a
+    CyclicSCC  as -> let inAs x = any (\(y,_,_) -> x == y) as
+                      in filter (not . inAs) (concatMap atomDeps as)
+
+atomDeps (_, _, ds) = ds
 
 process :: [ASTId] -> B.ByteString
 process = renderAll . group
 
 atomToId (n, m, p) = ID { idPackage = p, idModule = m, idName = n }
+
+idToAtom i = (idName i, idModule i, idPackage i)
+
+atomsToAstId (a, _, ds) = ASTId { aId   = atomToId a,
+                                  aDeps = map atomToId ds }
diff --git a/src/Main.hs b/src/Main.hs
deleted file mode 100644
index 039f35a06529959616d9742c75c71915a5c5e456..0000000000000000000000000000000000000000
--- a/src/Main.hs
+++ /dev/null
@@ -1,10 +0,0 @@
-module Main where
-
-import qualified Data.ByteString.Lazy       as B
-import qualified Data.ByteString.Lazy.Char8 as BC
-import           Grapher
-
-main :: IO ()
-main = do c <- B.getContents
-          let ps = parse c
-          BC.putStrLn (process ps)

From 7380fd3fae44e7a9eb6d3edda60f8a0cf5df6794 Mon Sep 17 00:00:00 2001
From: Chris Warburton <chriswarbo@gmail.com>
Date: Mon, 7 Mar 2016 23:11:31 +0000
Subject: [PATCH] Make algorithm greedy

---
 src/Grapher.hs | 67 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 61 insertions(+), 6 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 2d2cb191d7ba546a467028d07d0fbafc4227e4dd..b05ed2833cc47979b00b3cd5a0ef2253394855dc 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -35,6 +35,10 @@ extractGraphable x = let n = aName    x
                          d = aDeps    x
                       in ((n,m,p), (n,m,p), extractAtoms d)
 
+injectGraphable :: (Atom, Atom, [Atom]) -> ASTId
+injectGraphable (a, _, as) = ASTId { aId   = atomToId a,
+                                     aDeps = map atomToId as }
+
 parse :: B.ByteString -> [ASTId]
 parse s = case eitherDecode s of
                Left err -> error err
@@ -44,20 +48,71 @@ group :: [ASTId] -> [SCC Atom]
 group ids = stronglyConnComp atoms
   where atoms = map extractGraphable ids
 
-group' :: [ASTId] -> [SCC (Atom, Atom, [Atom])]
-group' = stronglyConnCompR . map extractGraphable
+group' :: [(Atom, Atom, [Atom])] -> [SCC (Atom, Atom, [Atom])]
+group' = stronglyConnCompR
+
+ungroup' :: [SCC (Atom, Atom, [Atom])] -> [(Atom, Atom, [Atom])]
+ungroup' = flattenSCCs
+
+-- Like group, but includes as many Atoms as possible in each group
+bigGroup :: [ASTId] -> [SCC Atom]
+bigGroup = bigSCCs . map extractGraphable
 
 leaves :: [ASTId] -> [ASTId]
 leaves = filter (null . aDeps)
 
+bigSCCs :: [(Atom, Atom, [Atom])] -> [SCC Atom]
+bigSCCs as = case nextSCC as of
+  Nothing -> []
+  Just y  -> y : bigSCCs (removeAtoms (sccAtoms y) as)
+
+sccAtoms :: SCC Atom -> [Atom]
+sccAtoms = flattenSCC
+
 -- Dependencies an SCC has on Atoms outside itself
 sccDeps :: SCC (Atom, Atom, [Atom]) -> [Atom]
 sccDeps s = case s of
-    AcyclicSCC a  -> atomDeps a
+    AcyclicSCC a  -> depAtoms a
     CyclicSCC  as -> let inAs x = any (\(y,_,_) -> x == y) as
-                      in filter (not . inAs) (concatMap atomDeps as)
-
-atomDeps (_, _, ds) = ds
+                      in filter (not . inAs) (concatMap depAtoms as)
+
+depLess :: [SCC (Atom, Atom, [Atom])] -> [SCC (Atom, Atom, [Atom])]
+depLess = filter (null . sccDeps)
+
+-- Combine as many elements as we can into one SCC
+nextSCC :: [(Atom, Atom, [Atom])] -> Maybe (SCC Atom)
+nextSCC [] = Nothing
+nextSCC as = forgetAtoms <$> combineSCCs sccs
+  where sccs = depLess (group' as)
+
+combineSCCs :: [SCC a] -> Maybe (SCC a)
+combineSCCs ss = case ss of
+  []     -> Nothing
+  [x]    -> Just x
+  (x:ys) -> case (x, combineSCCs ys) of
+    (_,            Nothing)             -> Just x
+    (AcyclicSCC a, Just (AcyclicSCC b)) -> Just (CyclicSCC [a, b])
+    (AcyclicSCC a, Just (CyclicSCC bs)) -> Just (CyclicSCC (a:bs))
+    (CyclicSCC as, Just (AcyclicSCC b)) -> Just (CyclicSCC (b:as))
+    (CyclicSCC as, Just (CyclicSCC bs)) -> Just (CyclicSCC (as ++ bs))
+
+forgetAtoms :: SCC (Atom, Atom, [Atom]) -> SCC Atom
+forgetAtoms (AcyclicSCC a) = AcyclicSCC (nameAtom a)
+forgetAtoms (CyclicSCC as) = CyclicSCC  (map nameAtom as)
+
+stripUnknownDeps :: [(Atom, Atom, [Atom])] -> [(Atom, Atom, [Atom])]
+stripUnknownDeps as = map strip as
+  where strip (x, y, zs) = (x, y, filter (`elem` known) zs)
+        known = map nameAtom as
+
+removeAtoms :: [Atom] -> [(Atom, Atom, [Atom])] -> [(Atom, Atom, [Atom])]
+removeAtoms as = stripUnknownDeps . filter (not . (`elem` as) . nameAtom)
+
+nameAtom :: (Atom, Atom, [Atom]) -> Atom
+nameAtom (n, _, _)  = n
+
+depAtoms :: (Atom, Atom, [Atom]) -> [Atom]
+depAtoms (_, _, ds) = ds
 
 process :: [ASTId] -> B.ByteString
 process = renderAll . group

From 9ebfda9bbb601cfe29b45c345d85e47e4d605a0f Mon Sep 17 00:00:00 2001
From: Chris Warburton <chriswarbo@gmail.com>
Date: Mon, 7 Mar 2016 23:14:02 +0000
Subject: [PATCH] Use bigGroup by default

---
 src/Grapher.hs | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index b05ed2833cc47979b00b3cd5a0ef2253394855dc..7423d8f41083da94f34de274f4fd210ab77780f4 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -44,9 +44,9 @@ parse s = case eitherDecode s of
                Left err -> error err
                Right ps -> ps
 
+-- Includes as many Atoms as possible in each group
 group :: [ASTId] -> [SCC Atom]
-group ids = stronglyConnComp atoms
-  where atoms = map extractGraphable ids
+group = bigSCCs . map extractGraphable
 
 group' :: [(Atom, Atom, [Atom])] -> [SCC (Atom, Atom, [Atom])]
 group' = stronglyConnCompR
@@ -54,10 +54,6 @@ group' = stronglyConnCompR
 ungroup' :: [SCC (Atom, Atom, [Atom])] -> [(Atom, Atom, [Atom])]
 ungroup' = flattenSCCs
 
--- Like group, but includes as many Atoms as possible in each group
-bigGroup :: [ASTId] -> [SCC Atom]
-bigGroup = bigSCCs . map extractGraphable
-
 leaves :: [ASTId] -> [ASTId]
 leaves = filter (null . aDeps)
 

From e13feb08dd1198e4b160e00d1a2a7fc2acb751cd Mon Sep 17 00:00:00 2001
From: Chris Warburton <chriswarbo@gmail.com>
Date: Tue, 8 Mar 2016 03:41:54 +0000
Subject: [PATCH] Fixes

---
 src/Grapher.hs | 11 +----------
 1 file changed, 1 insertion(+), 10 deletions(-)

diff --git a/src/Grapher.hs b/src/Grapher.hs
index 7423d8f41083da94f34de274f4fd210ab77780f4..ffdc3008377cee87c3e6c96837eefae7b2d14667 100644
--- a/src/Grapher.hs
+++ b/src/Grapher.hs
@@ -48,15 +48,6 @@ parse s = case eitherDecode s of
 group :: [ASTId] -> [SCC Atom]
 group = bigSCCs . map extractGraphable
 
-group' :: [(Atom, Atom, [Atom])] -> [SCC (Atom, Atom, [Atom])]
-group' = stronglyConnCompR
-
-ungroup' :: [SCC (Atom, Atom, [Atom])] -> [(Atom, Atom, [Atom])]
-ungroup' = flattenSCCs
-
-leaves :: [ASTId] -> [ASTId]
-leaves = filter (null . aDeps)
-
 bigSCCs :: [(Atom, Atom, [Atom])] -> [SCC Atom]
 bigSCCs as = case nextSCC as of
   Nothing -> []
@@ -79,7 +70,7 @@ depLess = filter (null . sccDeps)
 nextSCC :: [(Atom, Atom, [Atom])] -> Maybe (SCC Atom)
 nextSCC [] = Nothing
 nextSCC as = forgetAtoms <$> combineSCCs sccs
-  where sccs = depLess (group' as)
+  where sccs = depLess (stronglyConnCompR (stripUnknownDeps as))
 
 combineSCCs :: [SCC a] -> Maybe (SCC a)
 combineSCCs ss = case ss of
